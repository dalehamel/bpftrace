# Embedding dependencies

To make bpftrace more portable, it has long supported an alpine-based musl
build, which statically compiled bpftrace resulting in no runtime linking
required.

The drawback to this approach is that LLVM libraries, even when statically
compiled, depends on symbols from libdl, and works best and most predictably
when dynamically linked to libc.

To embed everything except for libc, building LLVM and Clang from source is
supported. This allows for linking to arbitrary libc targets dynamically, which
may provide the best of both worlds between a purely static and a purely
dynamically-linked bpftrace executable.

For this reason, there is CMake support in the bpftrace project to build LLVM
and Clang from source, as these are the heaviest dependencies of bpftrace.
Other library dependencies can be obtained by most package managers reliably.

Upstream packages provided by package maintainers can't be depended on to
present all of the necessary built artifacts to statically link against LLVM and
Clang, despite the project [llvm catering to this with its own CMake build
process](https://llvm.org/docs/CMake.html#embedding-llvm-in-your-project).

## Embedding clang

Clang is the actual dependency of bpftrace, as the src/ast folder pulls it in
for the interface that bpftraces uses for LLVM's code generation platform, which
ultimately outputs BPF instructions.

On the alpine platform, libclang.a is generated by default and a static build is
already achieved using this distribution. This libclang dependency is only
achievable with custom builds, or by using alpine.

To get around this problem, the `embed_clang.cmake` file provides the necessary
static libraries for bpftrace to link against, by downloading LLVM from a github
tagged release, and compiling it directly using custom cmake flags, based on
those provided by alpine already. This basically pulls the fairly simple
alpine-build "in-tree", using cmake flags based on it, and specifically
itemizing the libraries that will be link-time dependencies of bpftrace.

In turn, these clang libraries depend heavily on LLVM libraries, so this
necessitates having access to LLVM static libraries as well.

## Embedding LLVM

The Debian and Redhat LLVM packages don't bundle libclang, and have a
unavoidable dynamic library dependencies. This makes linking statically to
system provided LLVM is currently impracticable, as there is no way to shake
these dynamic dependencies with the system provided packages. 

This is because the Debian builds of LLVM [force linking to LibPolly](https://salsa.debian.org/pkg-llvm-team/llvm-toolchain/blob/8/debian/rules#L165),
but do not provide a static library for this, making it impossible to link
statically against this.

For this reason it is necessary to compile LLVM from source, to satisfy the
static dependencies that Clang has on LLVM libraries.

### Distribution patches

The LLVM builds maintained by distributions have patches on top of the tagged
releases. It may be favorable from time-to-time to pull in these patches.

By downloading patches from an external source and writing a custom series
file, `quilt` can be used to apply arbitrary patches to embedded sources.

# Building on CI

In order to build successfully in an environment like Travis CI, it is
necessary that build jobs complete in less than 50 minutes. Unfortunately, it
takes about 50 minutes to build just LLVM dependencies alone on Travis.

In order to build a new version of LLVM, or LLVM from a cold cache, the build
must be done incrementally. This is done with controlled timeouts, to make the
build complete within the 50 minute window. This allows for progress to be
saved, and another CI job to pick up where it left off. This is done by setting
the `CI_TIMEOUT` environment variable, currently to 40 minutes (to allow time
for static bcc to build and cache artifacts to be uploaded).

It may take several successive builds to rebuild the LLVM and Clang embedded
library dependencies, when a new embedded LLVM target is added or the cache is
cleared. Once the cache is warmed, the build times should be comparable to
other builds.

## Debug build

The debug build is too large to complete successfully on Travis CI. The debug
artifacts for LLVM and Clang build process are around 35GB, which simply takes
too long to save and restore on travis, resulting in builds being killed due
to travis' 10 minute no-output timeout. This makes the incremental approach
used to warm the cache for the Release binary impracticable. 

Debug builds ultimately produce a bpftrace binary that is 1.2GB, and not
practical for redistribution. When run locally or on a less restricted CI
environment, embedded Debug build should still complete and pass all tests, but
it may take 1-2 hours for this to complete from a cold cache.
